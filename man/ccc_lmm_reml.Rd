% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ccc_repeated.R
\name{ccc_lmm_reml}
\alias{ccc_lmm_reml}
\title{Concordance Correlation via REML (Linear Mixed-Effects Model)}
\usage{
ccc_lmm_reml(
  data,
  ry,
  rind,
  rmet = NULL,
  rtime = NULL,
  interaction = TRUE,
  max_iter = 100,
  tol = 1e-06,
  Dmat = NULL,
  ci = FALSE,
  conf_level = 0.95,
  verbose = FALSE,
  digits = 4,
  use_message = TRUE
)
}
\arguments{
\item{data}{A data frame.}

\item{ry}{Character. Response variable name.}

\item{rind}{Character. Subject ID variable name (random intercept).}

\item{rmet}{Character or \code{NULL}. Optional column name of method factor
(added to fixed effects).}

\item{rtime}{Character or \code{NULL}. Optional column name of time factor
(added to fixed effects).}

\item{interaction}{Logical. Include \code{method:time} interaction?
(default \code{TRUE}).}

\item{max_iter}{Integer. Maximum iterations for variance-component updates
(default \code{100}).}

\item{tol}{Numeric. Convergence tolerance on parameter change
(default \code{1e-6}).}

\item{Dmat}{Optional \eqn{n_t \times n_t} numeric matrix to weight/contrast
time levels when computing the fixed-effect dispersion term \eqn{S_B}.
Defaults to the identity.}

\item{ci}{Logical. If \code{TRUE}, return a CI container with NA limits
(see \strong{CIs} note below).}

\item{conf_level}{Numeric in \eqn{(0,1)}. Confidence level when
\code{ci=TRUE} (default \code{0.95}).}

\item{verbose}{Logical. If \code{TRUE}, prints a structured summary of the
fitted variance components and \eqn{S_B} for each fit (overall or
pairwise). Default \code{FALSE}.}

\item{digits}{Integer (\(\ge 0\)). Number of decimal places to use in the
printed summary when \code{verbose=TRUE}. Default \code{4}.}

\item{use_message}{Logical. When \code{verbose=TRUE}, choose the printing
mechanism, where \code{TRUE} uses \code{message()} (respects \code{sink()},
easily suppressible via \code{suppressMessages()}), whereas \code{FALSE}
uses \code{cat()} to \code{stdout}. Default \code{TRUE}.}
}
\value{
\itemize{
\item If \code{rmet} is \code{NULL} or has a single level, an object of
class \code{c("ccc","ccc_ci")} (when \code{ci=TRUE}) or
\code{c("ccc","matrix")} with a \eqn{1\times 1} matrix containing the
overall CCC estimate.
\item If \code{rmet} has \eqn{L\ge 2} levels, a symmetric \eqn{L\times L}
matrix with pairwise CCC estimates between methods (diagonal set to 1).
When \code{ci=TRUE}, \code{lwr.ci} and \code{upr.ci} matrices are
included.
}
In all cases, attributes \code{"method"}, \code{"description"},
\code{"package"}, and (if \code{ci=TRUE}) \code{"conf.level"} are set.
}
\description{
Compute Lin's Concordance Correlation Coefficient (CCC) from a linear
mixed-effects model fitted by REML. The fixed-effects part can include
\code{method} and/or \code{time} factors (and optionally their interaction),
while a subject-specific random intercept captures between-subject variation.
The implementation avoids any \eqn{n \times n}
inversions by working with small per-subject systems via the Woodbury
identity.
}
\details{
For measurement \eqn{y_{ij}} on subject \eqn{i} under fixed
levels (method, time), we fit
\deqn{ y = X\beta + Zu + \varepsilon,\qquad
       u \sim N(0,\,G),\ \varepsilon \sim N(0,\,\sigma_E^2 I). }
Here \eqn{Z} is the subject-structured random-effects design and \eqn{G} is
block-diagonal at the subject level with the following \emph{per-subject}
parameterization:
\itemize{
\item one random intercept with variance \eqn{\sigma_A^2};
\item optionally, \emph{method} deviations (one column per method level)
with a common variance \eqn{\sigma_{A\times M}^2} and zero
covariances across levels (i.e., multiple of an identity);
\item optionally, \emph{time} deviations (one column per time level)
with a common variance \eqn{\sigma_{A\times T}^2} and zero
covariances across levels.
}
The fixed-effects design is \code{~ 1 + rmet + rtime} and, if
\code{interaction=TRUE}, \code{+ rmet:rtime}.

\strong{Per-subject Woodbury system.} For subject \eqn{i} with \eqn{n_i}
rows, define the per-subject random-effects design \eqn{U_i} (columns:
intercept, method indicators, time indicators; dimension
\eqn{\,r=1+nm+nt\,}). The core never forms
\eqn{V_i = \sigma_E^2 I_{n_i} + U_i G U_i^\top} explicitly. Instead,
it builds
\deqn{ M_i \;=\; G^{-1} \;+\; \frac{1}{\sigma_E^2}\,U_i^\top U_i, }
and accumulates GLS blocks via rank-\eqn{r} corrections using
\eqn{\,V_i^{-1} = \tfrac{1}{\sigma_E^2}\big(I_{n_i} - U_i M_i^{-1}
U_i^\top / \sigma_E^2\big)}:
\deqn{ X^\top V^{-1} X \;=\; \sum_i \frac{1}{\sigma_E^2}\Big[
       X_i^\top X_i \;-\; (X_i^\top U_i)\,
       M_i^{-1}\,(U_i^\top X_i)/\sigma_E^2 \Big], }
\deqn{ X^\top V^{-1} y \;=\; \sum_i \frac{1}{\sigma_E^2}\Big[
       X_i^\top y_i \;-\; (X_i^\top U_i)\,M_i^{-1}\,
       (U_i^\top y_i)/\sigma_E^2 \Big]. }
Solves/inversions use symmetric-PD routines with a tiny diagonal "jitter" and
a pseudo-inverse fallback when needed.

\strong{EM-style variance-component updates.} With current \eqn{\hat\beta},
residuals \eqn{r_i = y_i - X_i\hat\beta} are formed. The BLUPs and
conditional covariances are
\deqn{ b_i \;=\; M_i^{-1}\,(U_i^\top r_i \!/\! \sigma_E^2), \qquad
      \mathrm{Var}(b_i\mid y) \;=\; M_i^{-1}. }
Expected squares yield closed-form updates:
\deqn{ \sigma_A^{2\,(new)} \;=\; \frac{1}{m}\sum_i \Big( b_{i,0}^2 +
(M_i^{-1})_{00} \Big), }
\deqn{ \sigma_{A\times M}^{2\,(new)} \;=\; \frac{1}{m\,nm}
      \sum_i \sum_{\ell=1}^{nm}\!\Big( b_{i,\ell}^2 +
      (M_i^{-1})_{\ell\ell} \Big)
      \quad (\text{if } nm>0), }
\deqn{ \sigma_{A\times T}^{2\,(new)} \;=\; \frac{1}{m\,nt}
      \sum_i \sum_{t=1}^{nt}\!\Big( b_{i,t}^2 + (M_i^{-1})_{tt} \Big)
      \quad (\text{if } nt>0), }
\deqn{ \sigma_E^{2\,(new)} \;=\; \frac{1}{n} \sum_i
      \Big( \| r_i - U_i b_i \|^2 + \mathrm{tr}\!\big(M_i^{-1} U_i^\top
      U_i\big) \Big). }
Iterate until the \eqn{\ell_1} change across components is \eqn{<}
\code{tol} or \code{max_iter} is reached.

\strong{Fixed-effect dispersion \eqn{\mathbf{S_B}}.} Method dispersion is
computed from \eqn{\hat\beta} and \eqn{\mathrm{Var}(\hat\beta)} with a
contrast matrix \eqn{L} (columns encode pairwise method differences within
each time level) and an optional time-weighting matrix \eqn{\mathrm{Dm}}:
\deqn{ S_B \;=\;
 \frac{\big(L^\top \hat\beta\big)^\top\,\mathrm{Dm}\,
 \big(L^\top \hat\beta\big)
       \;-\; \mathrm{tr}\!\Big(\big(L\,\mathrm{Dm}\,L^\top\big)\,
       \mathrm{Var}(\hat\beta)\Big)}
      {\,nm\,(nm-1)\,\max(nt,1)\,}, }
truncated at 0. The helper \code{\link{build_L_Dm}} constructs \eqn{L} so it
aligns exactly with the columns of \eqn{X=\mathrm{model.matrix}(\cdot)}
passed to 'C++'.
For exactly two methods (\eqn{nm=2}), a fast path builds \eqn{L} directly
from the design's column names, where, with interaction, the per-time
difference at time \eqn{j} is
\eqn{\beta_{\text{met2}}+\beta_{\text{met2:time}_j}} (baseline time uses
\eqn{\beta_{\text{met2}}}); while without interaction, the same
\eqn{\beta_{\text{met2}}} is used for all times.

\strong{Concordance correlation coefficient.} The CCC used is defined by
\deqn{ \mathrm{CCC} \;=\;
      \frac{\sigma_A^2 + \sigma_{A\times T}^2}
           {\sigma_A^2 + \sigma_{A\times M}^2 +
            \sigma_{A\times T}^2 + S_B + \sigma_E^2}. }
There are special cases when there is no method factor (or a single level),
then \eqn{S_B=0} and \eqn{\sigma_{A\times M}^2=0}; if there is no
time factor (or a single level), then \eqn{\sigma_{A\times T}^2=0}.

\strong{CIs / SEs (delta method for CCC).}
Let
\deqn{ \theta \;=\; \big(\sigma_A^2,\ \sigma_{A\times M}^2,\
\sigma_{A\times T}^2,\ \sigma_E^2,\ S_B\big)^\top, }
and write the concordance as
\deqn{ \mathrm{CCC}(\theta) \;=\; \frac{N}{D}
      \;=\; \frac{\sigma_A^2 + \sigma_{A\times T}^2}
                   {\sigma_A^2 + \sigma_{A\times M}^2 +
                   \sigma_{A\times T}^2 + S_B + \sigma_E^2}. }

A first-order (large-sample) standard error follows from the delta method:
\deqn{ \mathrm{Var}\{\widehat{\mathrm{CCC}}\}
      \;\approx\; \nabla \mathrm{CCC}(\hat\theta)^\top\,
                  \mathrm{Var}(\hat\theta)\,
                  \nabla \mathrm{CCC}(\hat\theta), }
with gradient components (using \eqn{N} and \eqn{D} as above)
\deqn{ \frac{\partial\,\mathrm{CCC}}{\partial \sigma_A^2}
      \;=\; \frac{D - N}{D^2}
      \;=\; \frac{\sigma_{A\times M}^2 + S_B + \sigma_E^2}{D^2}, }
\deqn{ \frac{\partial\,\mathrm{CCC}}{\partial \sigma_{A\times M}^2}
      \;=\; -\,\frac{N}{D^2}, \qquad
       \frac{\partial\,\mathrm{CCC}}{\partial \sigma_{A\times T}^2}
      \;=\; \frac{D - N}{D^2}, }
\deqn{ \frac{\partial\,\mathrm{CCC}}{\partial \sigma_E^2}
      \;=\; -\,\frac{N}{D^2}, \qquad
       \frac{\partial\,\mathrm{CCC}}{\partial S_B}
      \;=\; -\,\frac{N}{D^2}. }

\emph{Estimating \eqn{\mathrm{Var}(\hat\theta)}.}
The EM updates write each variance component as an average of per-subject
quantities. For subject \eqn{i},
\deqn{ t_{A,i} \;=\; b_{i,0}^2 + (M_i^{-1})_{00},\qquad
       t_{M,i} \;=\; \frac{1}{nm}\sum_{\ell=1}^{nm}
                       \Big(b_{i,\ell}^2 + (M_i^{-1})_{\ell\ell}\Big), }
\deqn{ t_{T,i} \;=\; \frac{1}{nt}\sum_{j=1}^{nt}
                       \Big(b_{i,j}^2 + (M_i^{-1})_{jj}\Big),\qquad
       s_i \;=\; \frac{\|r_i - U_i b_i\|^2 +
       \mathrm{tr}(M_i^{-1}U_i^\top U_i)}{n_i}, }
where \eqn{b_i = M_i^{-1}(U_i^\top r_i/\sigma_E^2)} and
\eqn{M_i = G^{-1} + U_i^\top U_i/\sigma_E^2}.
With \eqn{m} subjects, we form the empirical covariance of the stacked
subject vectors and scale by \eqn{m} to approximate the covariance of the
means:
\deqn{ \widehat{\mathrm{Cov}}\!\left(
      \begin{bmatrix} t_{A,\cdot} \\ t_{M,\cdot} \\ t_{T,\cdot} \end{bmatrix}
      \right)
      \;\approx\; \frac{1}{m}\,
       \mathrm{Cov}_i\!\left(
      \begin{bmatrix} t_{A,i} \\ t_{M,i} \\ t_{T,i} \end{bmatrix}\right). }
(Drop rows/columns as needed when \code{nm==0} or \code{nt==0}.)

The residual variance estimator is a weighted mean
\eqn{\hat\sigma_E^2=\sum_i w_i s_i} with \eqn{w_i=n_i/n}. Its variance is
approximated by the variance of a weighted mean of independent terms,
\deqn{ \widehat{\mathrm{Var}}(\hat\sigma_E^2)
      \;\approx\; \Big(\sum_i w_i^2\Big)\,\widehat{\mathrm{Var}}(s_i), }
where \eqn{\widehat{\mathrm{Var}}(s_i)} is the sample variance across
subjects. The method-dispersion term uses the quadratic-form delta already
computed for \eqn{S_B}:
\deqn{ \widehat{\mathrm{Var}}(S_B)
      \;=\; \frac{2\,\mathrm{tr}\!\big((A_{\!fix}\,\mathrm{Var}(\hat\beta))^2\big)
             \;+\; 4\,\hat\beta^\top A_{\!fix}\,\mathrm{Var}(\hat\beta)\,
             A_{\!fix}\,\hat\beta}
                   {\big[nm\,(nm-1)\,\max(nt,1)\big]^2}, }
with \eqn{A_{\!fix}=L\,\mathrm{Dm}\,L^\top}.

\emph{Putting it together.} Assemble
\eqn{\widehat{\mathrm{Var}}(\hat\theta)} by combining the
\eqn{(\sigma_A^2,\sigma_{A\times M}^2,\sigma_{A\times T}^2)} covariance
block from the subject-level empirical covariance, add the
\eqn{\widehat{\mathrm{Var}}(\hat\sigma_E^2)} and
\eqn{\widehat{\mathrm{Var}}(S_B)} terms on the diagonal,
and ignore cross-covariances across these blocks (a standard large-sample
simplification). Then
\deqn{ \widehat{\mathrm{se}}\{\widehat{\mathrm{CCC}}\}
      \;=\; \sqrt{\,\nabla \mathrm{CCC}(\hat\theta)^\top\,
                    \widehat{\mathrm{Var}}(\hat\theta)\,
                    \nabla \mathrm{CCC}(\hat\theta)\,}. }

A two-sided \eqn{(1-\alpha)} normal CI is
\deqn{ \widehat{\mathrm{CCC}} \;\pm\; z_{1-\alpha/2}\,
      \widehat{\mathrm{se}}\{\widehat{\mathrm{CCC}}\}, }
truncated to \eqn{[0,1]} in the output for convenience. When \eqn{S_B} is
truncated at 0 or samples are very small/imbalanced, the normal CI can be
mildly anti-conservative near the boundary; a logit transform for CCC or a
subject-level (cluster) bootstrap can be used for sensitivity analysis.
}
\section{Notes on stability and performance}{

All per-subject solves are \eqn{\,r\times r} with \eqn{r=1+nm+nt}, so cost
scales with the number of subjects and the fixed-effects dimension rather
than the total number of observations. Solvers use symmetric-PD paths with
a small diagonal ridge and pseudo-inverse fallback, which helps for
tiny/unbalanced subsets and near-boundary estimates. Very small samples or
extreme imbalance can still make \eqn{S_B} numerically delicate; negative
estimates are truncated to 0 by construction.
}

\examples{
#--------------------------------------------------------------------
## Two methods (no time)
#--------------------------------------------------------------------
set.seed(1)
n_subj <- 30
meth   <- factor(rep(c("A","B"), each = n_subj))
id     <- factor(rep(seq_len(n_subj), times = 2))
sigA <- 1.0; sigE <- 0.5
u  <- rnorm(n_subj, 0, sqrt(sigA))
y  <- c(u + rnorm(n_subj, 0, sqrt(sigE)),
         u + 0.2 + rnorm(n_subj, 0, sqrt(sigE)))
dat <- data.frame(y, id, method = meth)
ccc_lmm_reml(dat, ry = "y", rind = "id", rmet = "method")

# 95\% CI container (limits currently NA by design)
ccc_lmm_reml(dat, ry = "y", rind = "id", rmet = "method", ci = TRUE)

#--------------------------------------------------------------------
## Two methods x time (balanced 2x2), with and without interaction
#--------------------------------------------------------------------
dat$time <- factor(rep(rep(c("t1","t2"), each = n_subj/2), times = 2))
ccc_lmm_reml(dat, "y", "id", rmet = "method", rtime = "time",
             interaction = FALSE)
ccc_lmm_reml(dat, "y", "id", rmet = "method", rtime = "time",
             interaction = TRUE)

#--------------------------------------------------------------------
## Three methods - pairwise CCCs
#--------------------------------------------------------------------
set.seed(2)
n_subj <- 40
id     <- factor(rep(seq_len(n_subj), times = 3))
method <- factor(rep(c("A","B","C"), each = n_subj))
sigA <- 1.2; sigE <- 0.6
u  <- rnorm(n_subj, 0, sqrt(sigA))
mu <- c(A = 0.00, B = 0.15, C = -0.10)
e  <- rnorm(3 * n_subj, 0, sqrt(sigE))
y  <- u[as.integer(id)] + unname(mu[method]) + e
dat3 <- data.frame(y, id, method)
ccc_lmm_reml(dat3, "y", "id", rmet = "method")

}
\seealso{
\code{\link{build_L_Dm}} for constructing \eqn{L} and
\eqn{\mathrm{Dm}}; \code{\link{ccc_pairwise_u_stat}} for a U-statistic
alternative; and \pkg{cccrm} for a reference approach via \pkg{nlme}.
}
\author{
Thiago de Paula Oliveira
}
