% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ccc_repeated.R
\name{ccc_lmm_reml}
\alias{ccc_lmm_reml}
\title{Concordance Correlation via REML (Linear Mixed-Effects Model)}
\usage{
ccc_lmm_reml(
  data,
  ry,
  rind,
  rmet = NULL,
  rtime = NULL,
  interaction = TRUE,
  max_iter = 100,
  tol = 1e-06,
  Dmat = NULL,
  ci = FALSE,
  conf_level = 0.95
)
}
\arguments{
\item{data}{A data frame.}

\item{ry}{Character. Response variable name.}

\item{rind}{Character. Subject ID variable name (random intercept).}

\item{rmet}{Character or \code{NULL}. Optional column name of method factor
(added to fixed effects).}

\item{rtime}{Character or \code{NULL}. Optional column name of time factor
(added to fixed effects).}

\item{interaction}{Logical. Include \code{method:time} interaction?
(default \code{TRUE}).}

\item{max_iter}{Integer. Maximum iterations for variance-component updates
(default \code{100}).}

\item{tol}{Numeric. Convergence tolerance on parameter change
(default \code{1e-6}).}

\item{Dmat}{Optional \eqn{n_t \times n_t} numeric matrix to weight/contrast
time levels when computing the fixed-effect dispersion term \eqn{S_B}.
Defaults to the identity.}

\item{ci}{Logical. If \code{TRUE}, return a CI container with NA limits
(see \strong{CIs} note below).}

\item{conf_level}{Numeric in \eqn{(0,1)}. Confidence level when
\code{ci=TRUE} (default \code{0.95}).}
}
\value{
\itemize{
\item If \code{rmet} is \code{NULL} or has a single level, an object of
class \code{c("ccc","ccc_ci")} (when \code{ci=TRUE}) or
\code{c("ccc","matrix")} with a \eqn{1\times 1} matrix containing the
overall CCC estimate.
\item If \code{rmet} has \eqn{L\ge 2} levels, a symmetric \eqn{L\times L}
matrix with pairwise CCC estimates between methods (diagonal set to 1).
When \code{ci=TRUE}, \code{lwr.ci} and \code{upr.ci} matrices are
included.
}
In all cases, attributes \code{"method"}, \code{"description"},
\code{"package"}, and (if \code{ci=TRUE}) \code{"conf.level"} are set.
}
\description{
Compute Lin's Concordance Correlation Coefficient (CCC) from a linear
mixed-effects model fitted by REML. The fixed-effects part can include
\code{method} and/or \code{time} factors (and optionally their interaction),
while a subject-specific random intercept captures between-subject variation.
The implementation avoids any \eqn{n \times n}
inversions by working with small per-subject systems via the Woodbury
identity.
}
\details{
For measurement \eqn{y_{ij}} on subject \eqn{i} under fixed
levels (method, time), we fit
\deqn{ y = X\beta + Zu + \varepsilon,\qquad
       u \sim N(0,\,G),\ \varepsilon \sim N(0,\,\sigma_E^2 I). }
Here \eqn{Z} is the subject-structured random-effects design and \eqn{G} is
block-diagonal at the subject level with the following \emph{per-subject}
parameterization:
\itemize{
\item one random intercept with variance \eqn{\sigma_A^2};
\item optionally, \emph{method} deviations (one column per method level)
with a common variance \eqn{\sigma_{A\times M}^2} and zero
covariances across levels (i.e., multiple of an identity);
\item optionally, \emph{time} deviations (one column per time level)
with a common variance \eqn{\sigma_{A\times T}^2} and zero
covariances across levels.
}
The fixed-effects design is \code{~ 1 + rmet + rtime} and, if
\code{interaction=TRUE}, \code{+ rmet:rtime}.

\strong{Per-subject Woodbury system.} For subject \eqn{i} with \eqn{n_i}
rows, define the per-subject random-effects design \eqn{U_i} (columns:
intercept, method indicators, time indicators; dimension
\eqn{\,r=1+nm+nt\,}). The core never forms
\eqn{V_i = \sigma_E^2 I_{n_i} + U_i G U_i^\top} explicitly. Instead,
it builds
\deqn{ M_i \;=\; G^{-1} \;+\; \frac{1}{\sigma_E^2}\,U_i^\top U_i, }
and accumulates GLS blocks via rank-\eqn{r} corrections using
\eqn{\,V_i^{-1} = \tfrac{1}{\sigma_E^2}\big(I_{n_i} - U_i M_i^{-1}
U_i^\top / \sigma_E^2\big)}:
\deqn{ X^\top V^{-1} X \;=\; \sum_i \frac{1}{\sigma_E^2}\Big[
       X_i^\top X_i \;-\; (X_i^\top U_i)\,
       M_i^{-1}\,(U_i^\top X_i)/\sigma_E^2 \Big], }
\deqn{ X^\top V^{-1} y \;=\; \sum_i \frac{1}{\sigma_E^2}\Big[
       X_i^\top y_i \;-\; (X_i^\top U_i)\,M_i^{-1}\,
       (U_i^\top y_i)/\sigma_E^2 \Big]. }
Solves/inversions use symmetric-PD routines with a tiny diagonal "jitter" and
a pseudo-inverse fallback when needed.

\strong{EM-style variance-component updates.} With current \eqn{\hat\beta},
residuals \eqn{r_i = y_i - X_i\hat\beta} are formed. The BLUPs and
conditional covariances are
\deqn{ b_i \;=\; M_i^{-1}\,(U_i^\top r_i \!/\! \sigma_E^2), \qquad
      \mathrm{Var}(b_i\mid y) \;=\; M_i^{-1}. }
Expected squares yield closed-form updates:
\deqn{ \sigma_A^{2\,(new)} \;=\; \frac{1}{m}\sum_i \Big( b_{i,0}^2 +
(M_i^{-1})_{00} \Big), }
\deqn{ \sigma_{A\times M}^{2\,(new)} \;=\; \frac{1}{m\,nm}
      \sum_i \sum_{\ell=1}^{nm}\!\Big( b_{i,\ell}^2 +
      (M_i^{-1})_{\ell\ell} \Big)
      \quad (\text{if } nm>0), }
\deqn{ \sigma_{A\times T}^{2\,(new)} \;=\; \frac{1}{m\,nt}
      \sum_i \sum_{t=1}^{nt}\!\Big( b_{i,t}^2 + (M_i^{-1})_{tt} \Big)
      \quad (\text{if } nt>0), }
\deqn{ \sigma_E^{2\,(new)} \;=\; \frac{1}{n} \sum_i
      \Big( \| r_i - U_i b_i \|^2 + \mathrm{tr}\!\big(M_i^{-1} U_i^\top
      U_i\big) \Big). }
Iterate until the \eqn{\ell_1} change across components is \eqn{<}
\code{tol} or \code{max_iter} is reached.

\strong{Fixed-effect dispersion \eqn{\mathbf{S_B}}.} Method dispersion is
computed from \eqn{\hat\beta} and \eqn{\mathrm{Var}(\hat\beta)} with a
contrast matrix \eqn{L} (columns encode pairwise method differences within
each time level) and an optional time-weighting matrix \eqn{\mathrm{Dm}}:
\deqn{ S_B \;=\;
 \frac{\big(L^\top \hat\beta\big)^\top\,\mathrm{Dm}\,
 \big(L^\top \hat\beta\big)
       \;-\; \mathrm{tr}\!\Big(\big(L\,\mathrm{Dm}\,L^\top\big)\,
       \mathrm{Var}(\hat\beta)\Big)}
      {\,nm\,(nm-1)\,\max(nt,1)\,}, }
truncated at 0. The helper \code{\link{build_L_Dm}} constructs \eqn{L} so it
aligns exactly with the columns of \eqn{X=\mathrm{model.matrix}(\cdot)}
passed to 'C++'.
For exactly two methods (\eqn{nm=2}), a fast path builds \eqn{L} directly
from the design's column names, where, with interaction, the per-time
difference at time \eqn{j} is
\eqn{\beta_{\text{met2}}+\beta_{\text{met2:time}_j}} (baseline time uses
\eqn{\beta_{\text{met2}}}); while without interaction, the same
\eqn{\beta_{\text{met2}}} is used for all times.

\strong{Concordance correlation coefficient.} The CCC used is defined by
\deqn{ \mathrm{CCC} \;=\;
      \frac{\sigma_A^2 + \sigma_{A\times T}^2}
           {\sigma_A^2 + \sigma_{A\times M}^2 +
            \sigma_{A\times T}^2 + S_B + \sigma_E^2}. }
There are special cases when there is no method factor (or a single level),
then \eqn{S_B=0} and \eqn{\sigma_{A\times M}^2=0}; if there is no
time factor (or a single level), then \eqn{\sigma_{A\times T}^2=0}.

\strong{CIs / SEs.}
}
\section{Notes on stability and performance}{

All per-subject solves are \eqn{\,r\times r} with \eqn{r=1+nm+nt}, so cost
scales with the number of subjects and the fixed-effects dimension rather
than the total number of observations. Solvers use symmetric-PD paths with
a small diagonal ridge and pseudo-inverse fallback, which helps for
tiny/unbalanced subsets and near-boundary estimates. Very small samples or
extreme imbalance can still make \eqn{S_B} numerically delicate; negative
estimates are truncated to 0 by construction.
}

\examples{
#--------------------------------------------------------------------
## Two methods (no time)
#--------------------------------------------------------------------
set.seed(1)
n_subj <- 30
meth   <- factor(rep(c("A","B"), each = n_subj))
id     <- factor(rep(seq_len(n_subj), times = 2))
sigA <- 1.0; sigE <- 0.5
u  <- rnorm(n_subj, 0, sqrt(sigA))
y  <- c(u + rnorm(n_subj, 0, sqrt(sigE)),
         u + 0.2 + rnorm(n_subj, 0, sqrt(sigE)))
dat <- data.frame(y, id, method = meth)
ccc_lmm_reml(dat, ry = "y", rind = "id", rmet = "method")

# 95\% CI container (limits currently NA by design)
ccc_lmm_reml(dat, ry = "y", rind = "id", rmet = "method", ci = TRUE)

#--------------------------------------------------------------------
## Two methods x time (balanced 2x2), with and without interaction
#--------------------------------------------------------------------
dat$time <- factor(rep(rep(c("t1","t2"), each = n_subj/2), times = 2))
ccc_lmm_reml(dat, "y", "id", rmet = "method", rtime = "time",
             interaction = FALSE)
ccc_lmm_reml(dat, "y", "id", rmet = "method", rtime = "time",
             interaction = TRUE)

#--------------------------------------------------------------------
## Three methods - pairwise CCCs
#--------------------------------------------------------------------
set.seed(2)
n_subj <- 40
id     <- factor(rep(seq_len(n_subj), times = 3))
method <- factor(rep(c("A","B","C"), each = n_subj))
sigA <- 1.2; sigE <- 0.6
u  <- rnorm(n_subj, 0, sqrt(sigA))
mu <- c(A = 0.00, B = 0.15, C = -0.10)
e  <- rnorm(3 * n_subj, 0, sqrt(sigE))
y  <- u[as.integer(id)] + unname(mu[method]) + e
dat3 <- data.frame(y, id, method)
ccc_lmm_reml(dat3, "y", "id", rmet = "method")

}
\seealso{
\code{\link{build_L_Dm}} for constructing \eqn{L} and
\eqn{\mathrm{Dm}}; \code{\link{ccc_pairwise_u_stat}} for a U-statistic
alternative; and \pkg{cccrm} for a reference approach via \pkg{nlme}.
}
\author{
Thiago de Paula Oliveira
}
